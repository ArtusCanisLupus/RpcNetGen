namespace RpcNetGen
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;

    internal static class Program
    {
        private const string Version = "1.0.0";

        public static readonly Dictionary<string, ParsedElementBase> GlobalIdentifiers =
            new Dictionary<string, ParsedElementBase>();

        public static string BaseClassname;
        public static string ConstantsClassname;

        private static readonly Dictionary<string, string> _baseTypes = new Dictionary<string, string>
        {
            { "void", "Void" },
            { "bool", "Bool" },
            { "byte", "Byte" },
            { "short", "Short" },
            { "ushort", "UShort" },
            { "int", "Int" },
            { "uint", "UInt" },
            { "long", "Long" },
            { "ulong", "ULong" },
            { "float", "Float" },
            { "double", "Double" },
            { "string", "String" }
        };

        private static List<ParsedProgramInfo> _programInfos;
        private static string _inputFilePath;
        private static string _outputFilePath;
        private static StreamWriter _outputFile;
        private static string _namespace;

        public static void SetProgramInfos(IEnumerable programInfos) =>
            _programInfos = programInfos.Cast<ParsedProgramInfo>().ToList();

        public static void AddElement(string id, ParsedElementBase element)
        {
            if (GlobalIdentifiers.ContainsKey(id))
            {
                Console.WriteLine($"ID {id} is already defined.");
                Environment.Exit(1);
            }

            GlobalIdentifiers.Add(id, element);
        }

        private static void PrintHelp()
        {
            Console.WriteLine("Usage: RpcNetGen [-options] x-file");
            Console.WriteLine();
            Console.WriteLine("where options include:");
            Console.WriteLine("  -o <output file> specify output file");
            Console.WriteLine("  -n <namespace>   specify namespace for output file");
            Console.WriteLine("  -? -help         print this help message and exit");
            Console.WriteLine();
        }

        private static void CreateSourceFile()
        {
            _outputFile = new StreamWriter(_outputFilePath);

            _outputFile.WriteLine("//------------------------------------------------------------------------------");
            _outputFile.WriteLine("// <auto-generated>");
            _outputFile.WriteLine($"//     This code was generated by RpcNetGen {Version}.");
            _outputFile.WriteLine("//");
            _outputFile.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            _outputFile.WriteLine("//     the code is regenerated.");
            _outputFile.WriteLine("// </auto-generated>");
            _outputFile.WriteLine("//------------------------------------------------------------------------------");
            _outputFile.WriteLine();

            if (!string.IsNullOrWhiteSpace(_namespace))
            {
                _outputFile.WriteLine($"namespace {_namespace}");
                _outputFile.WriteLine("{");
            }

            _outputFile.WriteLine("    using System;");
            _outputFile.WriteLine("    using System.Net;");
            _outputFile.WriteLine("    using RpcNet;");
        }

        private static void CloseSourceFile()
        {
            if (!string.IsNullOrWhiteSpace(_namespace))
            {
                _outputFile.WriteLine("}");
            }

            _outputFile.Dispose();
        }

        private static void DumpConstantAndDependency(ParsedConst c)
        {
            // This simple test avoids endless recursions: we already dumped this particular constant in some place, so
            // we should not proceed
            if (c.DoNotTraverseAnyMore)
            {
                return;
            }

            // Since we will dump the constant below, we already set the flag, to avoid endless recursions
            c.DoNotTraverseAnyMore = true;
            if (c.DependencyIdentifier != null)
            {
                // There is a dependency, so try to resolve that first. In case we depend on another identifier
                // belonging to the same enclosure, we dump this other identifier first. However, if the identifier we
                // depend on belongs to a different enclosure, then we must not dump it: this will be the job of a later
                // call when the proper enclosure is in the works
                if (GlobalIdentifiers.TryGetValue(c.DependencyIdentifier, out ParsedElementBase value) && value is ParsedConst dc)
                {
                    if (!c.Enclosure.Equals(dc.Enclosure, StringComparison.OrdinalIgnoreCase))
                    {
                        // In case we depend on a constant which belongs to a different enclosure then also dump the
                        // enclosure. Note that this code depends on the "value"
                        // starts with the identifier we depend on (which is currently the case), so we just need to
                        // prepend the enclosure
                        _outputFile.WriteLine(
                            $"        public const int {c.Identifier} = {dc.Enclosure}.{c.Value};");
                        return;
                    }

                    // Only dump the identifier we're dependent on, if it's in the same enclosure
                    DumpConstantAndDependency(dc);
                }
            }

            // Just dump the plain value (without enclosure)
            _outputFile.WriteLine($"        public const int {c.Identifier} = {c.Value};");
        }

        private static void DumpConstants()
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine("    internal static class " + ConstantsClassname);
            _outputFile.WriteLine("    {");
            foreach (ParsedElementBase parsedElement in GlobalIdentifiers.Values)
            {
                if (parsedElement is ParsedConst parsedConst)
                {
                    // Dump only such constants which belong to the global constants enclosure. Ignore all other
                    // constants, as those belong to other C# class enclosures
                    if (BaseClassname.Equals(parsedConst.Enclosure))
                    {
                        DumpConstantAndDependency(parsedConst);
                    }
                }
            }

            _outputFile.WriteLine("    }");
        }

        private static void DumpEnum(ParsedEnum e)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"    internal enum {e.Identifier}");
            _outputFile.WriteLine("    {");
            foreach (ParsedConst enumElement in e.EnumElements)
            {
                _outputFile.WriteLine($"        {enumElement.Identifier} = {enumElement.Value},");
            }

            _outputFile.WriteLine("    }");
        }

        private static string XdrBaseType(string type)
        {
            if (type == "opaque")
            {
                type = "byte";
            }
            else if (type == "bool")
            {
                return "XdrBool";
            }

            if (_baseTypes.TryGetValue(type, out string baseType))
            {
                return "Xdr" + baseType;
            }

            return null;
        }

        private static WriteReadOptions BaseEnDecodingSyllable(ParsedDeclaration decl, bool encode)
        {
            string writeFunction = "Write";
            string readFunction = "Read" + decl.DataType;
            bool isBase = false;
            // Check for C# base data types... if a match is found, then convert the data type name, so that it
            // becomes a valid syllable for use with XDR en-/decoding functions XdrEncodingXXX() etc. Example: "int" -->
            // "Int" (because of XdrEncodingInt()) NOTE: we consider "opaque" to be a base type here...
            string type = decl.DataType;
            if (type == "opaque")
            {
                type = "byte";
            }

            if (_baseTypes.TryGetValue(type, out string baseType))
            {
                isBase = true;
                readFunction = "Read" + baseType;
            }

            bool isEnum = false;
            // Handle special case of enumerations, which have to be represented using integers in the C# language.
            if (!isBase && GlobalIdentifiers.TryGetValue(decl.DataType, out ParsedElementBase o) && o is ParsedEnum)
            {
                isBase = true;
                isEnum = true;
                readFunction = "ReadInt";
            }

            if (!isBase)
            {
                return null;
            }

            string writeAppendix = null;
            string readAppendix = null;
            if (decl.Kind == DeclarationType.FixedVector || decl.Kind == DeclarationType.DynamicVector)
            {
                if (decl.DataType == "opaque")
                {
                    if (decl.Kind == DeclarationType.FixedVector)
                    {
                        writeAppendix = $".AsSpan<byte>(0, {CheckForConstant(decl.Size)})";
                        readAppendix = CheckForConstant(decl.Size);
                        writeFunction = "WriteFixedLengthOpaque";
                    }
                    else
                    {
                        writeFunction = "WriteVariableLengthOpaque";
                    }

                    readFunction = "ReadOpaque";
                }
                else if (decl.DataType != "string")
                {
                    if (decl.Kind == DeclarationType.FixedVector)
                    {
                        writeAppendix = $".AsSpan<{decl.DataType.ToLower()}>(0, {CheckForConstant(decl.Size)})";
                        readAppendix = CheckForConstant(decl.Size);
                        writeFunction = "WriteFixedLengthArray";
                    }
                    else
                    {
                        writeFunction = "WriteVariableLengthArray";
                    }

                    readFunction += "Array";
                }
            }

            return new WriteReadOptions(writeFunction, readFunction, writeAppendix, readAppendix, isEnum);
        }

        private static string CodingMethod(ParsedDeclaration decl, bool encode, string outerRef = null)
        {
            // Skip entries for void arms etc...
            if (decl.Identifier == null)
            {
                return string.Empty;
            }

            WriteReadOptions data = BaseEnDecodingSyllable(decl, encode);

            string identifier = decl.Identifier;
            if (!string.IsNullOrWhiteSpace(outerRef))
            {
                identifier = outerRef + "." + identifier;
            }

            if (data?.IsEnum == true)
            {
                if (decl.Kind == DeclarationType.Scalar)
                {
                    return encode ? EncodeScalarEnum(data, identifier) : DecodeScalarEnum(decl, identifier, data);
                }

                return encode ? EncodeVectorEnum(decl, identifier) : DecodeVectorEnum(decl, identifier);
            }

            if (data != null)
            {
                return encode ? EncodeScalarBaseType(data, identifier) : DecodeScalarBaseType(identifier, data);
            }

            if (decl.Kind == DeclarationType.Scalar)
            {
                return encode ? EncodeScalar(identifier) : DecodeScalar(decl, identifier);
            }

            if (decl.Kind == DeclarationType.Indirection)
            {
                return encode ? EncodeIndirection(identifier) : DecodeIndirection(decl, identifier);
            }

            return encode ? EncodeVector(decl, identifier) : DecodeVector(decl, identifier);
        }

        private static string EncodeScalarEnum(WriteReadOptions data, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        writer.");
            code.Append(data.WriteFunction);
            code.Append("((int)");
            code.Append(identifier);
            code.Append(data.WriteAppendix);
            code.AppendLine(");");
            return code.ToString();
        }

        private static string DecodeScalarEnum(ParsedDeclaration decl, string identifier, WriteReadOptions data)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = (");
            code.Append(decl.DataType);
            code.Append(")reader.");
            code.Append(data.ReadFunction);
            code.Append("(");
            code.Append(data.ReadAppendix);
            code.AppendLine(");");
            return code.ToString();
        }

        private static string EncodeVectorEnum(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                code.Append(identifier);
                code.Append("?.Length ?? 0");
            }
            else
            {
                code.Append(CheckForConstant(decl.Size));
            }

            code.Append("; ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                code.Append("writer.Write(_size); ");
            }

            code.Append("for (int _idx = 0; _idx < _size; _idx++) { writer.Write((int)");
            code.Append(identifier);
            code.AppendLine("[_idx]); } }");
            return code.ToString();
        }

        private static string DecodeVectorEnum(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            code.Append(decl.Kind == DeclarationType.DynamicVector
                ? "reader.ReadInt()"
                : CheckForConstant(decl.Size));

            code.Append("; ");
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.Append("[_size]; for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.Append("[_idx] = (");
            code.Append(decl.DataType);
            code.AppendLine(")reader.ReadInt(); } }");
            return code.ToString();
        }

        private static string EncodeScalarBaseType(WriteReadOptions data, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        writer.");
            code.Append(data.WriteFunction);
            code.Append("(");
            code.Append(identifier);
            code.Append(data.WriteAppendix);
            code.AppendLine(");");
            return code.ToString();
        }

        private static string DecodeScalarBaseType(string identifier, WriteReadOptions data)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = reader.");
            code.Append(data.ReadFunction);
            code.Append("(");
            code.Append(data.ReadAppendix);
            code.AppendLine(");");
            return code.ToString();
        }

        private static string EncodeScalar(string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.AppendLine("?.WriteTo(writer);");
            return code.ToString();
        }

        private static string DecodeScalar(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.AppendLine("(reader);");
            return code.ToString();
        }

        private static string EncodeIndirection(string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append("if (");
            code.Append(identifier);
            code.Append(" != null) { writer.Write(true); ");
            code.Append(identifier);
            code.AppendLine(".WriteTo(writer); } else { writer.Write(false); }");
            return code.ToString();
        }

        private static string DecodeIndirection(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = read.ReadBool() ? new ");
            code.Append(decl.DataType);
            code.AppendLine("(reader) : null;");
            return code.ToString();
        }

        private static string EncodeVector(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                // Dynamic array size. So we need to use the current size of the C# array
                code.Append(identifier);
                code.Append("?.Length ?? 0");
            }
            else
            {
                code.Append(CheckForConstant(decl.Size));
            }

            code.Append("; ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                // Dynamic array size. So we need to encode size information
                code.Append("writer.Write(_size); ");
            }

            // Now encode all elements
            code.Append("for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.AppendLine("[_idx].WriteTo(writer); } }");
            return code.ToString();
        }

        private static string DecodeVector(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            code.Append(decl.Kind == DeclarationType.DynamicVector
                ? "reader.ReadInt()"
                : CheckForConstant(decl.Size));

            code.Append("; ");

            // Now encode all elements
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.Append("[_size]; for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.Append("[_idx] = new ");
            code.Append(decl.DataType);
            code.AppendLine("(reader); } }");
            return code.ToString();
        }

        private static string CheckForSpecials(string dataType)
        {
            return "opaque".Equals(dataType) ? "byte" : dataType;
        }

        private static string CheckForConstant(string value)
        {
            if (value.Length > 0)
            {
                // If the value is an integer literal, then we just have to return it
                if (char.IsDigit(value[0]) || value[0] == '-')
                {
                    return value;
                }

                // It's an identifier: we now need to find out in which enclosure it lives, so we can return a qualified
                // identifier
                ParsedElementBase id = GlobalIdentifiers[value];
                if (id is ParsedConst c)
                {
                    return c.Enclosure == null ? c.Value : c.Enclosure + "." + c.Identifier;
                }
            }

            return value;
        }

        private static void DumpStruct(ParsedStruct s)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"    internal partial class {s.Identifier} : IXdrReadable, IXdrWritable");
            _outputFile.WriteLine("    {");

            // Generate declarations of all members of this XDR struct. This the perfect place to also update the hash
            // function using the elements together with their type
            bool useIteration = false;
            for (int i = 0; i < s.Elements.Count; i++)
            {
                ParsedDeclaration d = s.Elements[i];
                _outputFile.Write($"        public {CheckForSpecials(d.DataType)}");
                if ((d.Kind == DeclarationType.FixedVector || d.Kind == DeclarationType.DynamicVector) &&
                    !d.DataType.Equals("string"))
                {
                    _outputFile.Write("[]");
                }

                _outputFile.Write($" {d.Identifier} {{ get; set; }}");
                if (d.DataType.Equals("string"))
                {
                    _outputFile.Write(" = \"\";");
                }

                _outputFile.WriteLine();

                // If the last element in the XDR struct is a reference to the type of the XDR struct (that is, a linked
                // list), then we can convert this tail recursion into an iteration, avoiding deep recursions for large
                // lists
                if (i == s.Elements.Count - 1 &&
                    d.Kind == DeclarationType.Indirection &&
                    d.DataType.Equals(s.Identifier))
                {
                    useIteration = true;
                }
            }

            // Now generate code for encoding and decoding this class (structure).
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {s.Identifier}()");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {s.Identifier}(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("            ReadFrom(reader);");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void WriteTo(IXdrWriter writer)");
            _outputFile.WriteLine("        {");
            if (useIteration)
            {
                _outputFile.WriteLine("            var current = this;");
                _outputFile.WriteLine("            do");
                _outputFile.WriteLine("            {");

                for (int i = 0; i < s.Elements.Count - 1; i++)
                {
                    _outputFile.Write("        " + CodingMethod(s.Elements[i], true, "current"));
                }

                _outputFile.WriteLine($"                current = current.{s.Elements[s.Elements.Count - 1].Identifier};");
                _outputFile.WriteLine("                writer.Write(current != null);");
                _outputFile.WriteLine("            } while (current != null);");
            }
            else
            {
                foreach (ParsedDeclaration declaration in s.Elements)
                {
                    _outputFile.Write("    " + CodingMethod(declaration, true));
                }
            }

            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void ReadFrom(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            if (useIteration)
            {
                _outputFile.WriteLine("            var current = this;");
                _outputFile.WriteLine($"            {s.Identifier} next;");
                _outputFile.WriteLine("            do");
                _outputFile.WriteLine("            {");

                for (int i = 0; i < s.Elements.Count - 1; i++)
                {
                    _outputFile.Write("        " + CodingMethod(s.Elements[i], false, "current"));
                }

                _outputFile.WriteLine(
                    $"                next = reader.ReadBool() ? new {s.Identifier}() : null;");
                _outputFile.WriteLine($"                current.{s.Elements[s.Elements.Count - 1].Identifier} = next;");
                _outputFile.WriteLine("                current = next;");
                _outputFile.WriteLine("            } while (current != null);");
            }
            else
            {
                foreach (ParsedDeclaration declaration in s.Elements)
                {
                    _outputFile.Write("    " + CodingMethod(declaration, false));
                }
            }

            _outputFile.WriteLine("        }");
            _outputFile.WriteLine("    }");
        }

        private static void DumpUnion(ParsedUnion u)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"    internal partial class {u.Identifier} : IXdrReadable, IXdrWritable");
            _outputFile.WriteLine("    {");

            // Note that the descriminant can not be of an array type, string, etc. so we don't have to handle all the
            // special cases here
            _outputFile.WriteLine(
                $"        public {CheckForSpecials(u.Descriminant.DataType)} {u.Descriminant.Identifier} {{ get; set; }}");
            bool boolDescriminant = u.Descriminant.DataType.Equals("bool");
            foreach (ParsedUnionArm unionArm in u.Elements)
            {
                // Skip all arms which do not contain a variable but are declared as "void" instead. Also skip all arms
                // which are mapped to another arm
                if (unionArm.Element?.Identifier == null)
                {
                    continue;
                }

                _outputFile.Write("        public " + CheckForSpecials(unionArm.Element.DataType));
                if ((unionArm.Element.Kind == DeclarationType.FixedVector ||
                     unionArm.Element.Kind == DeclarationType.DynamicVector) &&
                    unionArm.Element.DataType != "string")
                {
                    _outputFile.Write("[]");
                }

                _outputFile.WriteLine($" {unionArm.Element.Identifier} {{ get; set; }}");
            }

            // Now generate code for encoding and decoding this class (structure).
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {u.Identifier}()");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {u.Identifier}(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("            ReadFrom(reader);");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void WriteTo(IXdrWriter writer)");
            _outputFile.WriteLine("        {");
            _outputFile.Write("    " + CodingMethod(u.Descriminant, true));
            if (!boolDescriminant)
            {
                // Produce code using an ordinary switch statement...
                _outputFile.WriteLine($"            switch ({u.Descriminant.Identifier})");
                _outputFile.WriteLine("            {");
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    _outputFile.WriteLine(unionArm.Value != null
                        ? $"                case {CheckForConstant(unionArm.Value)}:"
                        : "                default:");

                    // Only emit code if arm does not map to another arm.
                    if (unionArm.Element != null)
                    {
                        if (unionArm.Element.Identifier != null)
                        {
                            // Arm does not contain void, so we need to spit out encoding instructions.
                            _outputFile.Write("            " + CodingMethod(unionArm.Element, true));
                        }

                        _outputFile.WriteLine("                    break;");
                    }
                }

                _outputFile.WriteLine("            }");
            }
            else
            {
                // boolean descriminant: here we can have at most two arms, guess why.
                bool firstArm = true;
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null)
                    {
                        // Skip default branch this time...
                        continue;
                    }

                    if (unionArm.Element.Identifier != null)
                    {
                        // Arm contains data, so we need to create encoding instructions.
                        _outputFile.Write("        ");
                        if (!firstArm)
                        {
                            _outputFile.Write("else ");
                        }
                        else
                        {
                            firstArm = false;
                        }

                        _outputFile.WriteLine(
                            $"if ({u.Descriminant.Identifier} == {CheckForConstant(unionArm.Value)}) {{");
                        _outputFile.Write("    ");
                        _outputFile.Write(CodingMethod(unionArm.Element, true));
                        _outputFile.WriteLine("        }");
                    }
                }

                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null && unionArm.Element.Identifier != null)
                    {
                        _outputFile.Write("        ");
                        if (!firstArm)
                        {
                            _outputFile.Write("else ");
                        }

                        _outputFile.WriteLine("{");
                        _outputFile.Write("    ");
                        _outputFile.Write(CodingMethod(unionArm.Element, true));
                        _outputFile.WriteLine("        }");
                    }
                }
            }

            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void ReadFrom(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            _outputFile.Write("    " + CodingMethod(u.Descriminant, false));
            if (!boolDescriminant)
            {
                // Produce code using an ordinary switch statement...
                _outputFile.WriteLine($"            switch ({u.Descriminant.Identifier})");
                _outputFile.WriteLine("            {");
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    _outputFile.WriteLine(unionArm.Value != null
                        ? $"                case {CheckForConstant(unionArm.Value)}:"
                        : "                default:");

                    // Only emit code if arm does not map to another arm.
                    if (unionArm.Element != null)
                    {
                        if (unionArm.Element.Identifier != null)
                        {
                            // Arm does not contain void, so we need to spit out encoding instructions.
                            _outputFile.Write("            " + CodingMethod(unionArm.Element, false));
                        }

                        _outputFile.WriteLine("                    break;");
                    }
                }

                _outputFile.WriteLine("            }");
            }
            else
            {
                // boolean descriminant: here we can have at most two arms, guess why.
                bool firstArm = true;
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null)
                    {
                        // Skip default branch this time...
                        continue;
                    }

                    if (unionArm.Element.Identifier != null)
                    {
                        // Arm contains data, so we need to create encoding instructions.
                        _outputFile.Write("        ");
                        if (!firstArm)
                        {
                            _outputFile.Write("else ");
                        }
                        else
                        {
                            firstArm = false;
                        }

                        _outputFile.WriteLine(
                            $"if ({u.Descriminant.Identifier} == {CheckForConstant(unionArm.Value)}) {{");
                        _outputFile.Write("    ");
                        _outputFile.Write(CodingMethod(unionArm.Element, false));
                        _outputFile.WriteLine("        }");
                    }
                }

                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null && unionArm.Element.Identifier != null)
                    {
                        _outputFile.Write("        ");
                        if (!firstArm)
                        {
                            _outputFile.Write("else ");
                        }

                        _outputFile.WriteLine("{");
                        _outputFile.Write("    ");
                        _outputFile.Write(CodingMethod(unionArm.Element, false));
                        _outputFile.WriteLine("        }");
                    }
                }
            }

            _outputFile.WriteLine("        }");
            _outputFile.WriteLine("    }");
        }

        private static void DumpTypedef(ParsedDeclaration d)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"    internal partial class {d.Identifier} : IXdrReadable, IXdrWritable");
            _outputFile.WriteLine("    {");
            string paramType = CheckForSpecials(d.DataType);
            if ((d.Kind == DeclarationType.FixedVector || d.Kind == DeclarationType.DynamicVector) &&
                !d.DataType.Equals("string"))
            {
                paramType += " []";
            }

            _outputFile.Write($"        public {paramType} Value {{ get; set; }}");
            _outputFile.WriteLine();

            // Now generate code for encoding and decoding this class (typedef).
            var declaration = new ParsedDeclaration("Value", d.DataType, d.Kind, d.Size);
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {d.Identifier}()");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {d.Identifier}({paramType} value)");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("            Value = value;");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        public {d.Identifier}(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("            ReadFrom(reader);");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void WriteTo(IXdrWriter writer)");
            _outputFile.WriteLine("        {");
            _outputFile.Write("    " + CodingMethod(declaration, true));
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            _outputFile.WriteLine("        public void ReadFrom(IXdrReader reader)");
            _outputFile.WriteLine("        {");
            _outputFile.Write("    " + CodingMethod(declaration, false));
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine("    }");
        }

        private static void DumpClasses()
        {
            foreach (ParsedElementBase parsedElement in GlobalIdentifiers.Values.OrderBy(v => v.Identifier))
            {
                switch (parsedElement)
                {
                    case ParsedEnum parsedEnum:
                        DumpEnum(parsedEnum);
                        break;
                    case ParsedStruct parsedStruct:
                        DumpStruct(parsedStruct);
                        break;
                    case ParsedUnion parsedUnion:
                        DumpUnion(parsedUnion);
                        break;
                    case ParsedDeclaration parsedDeclaration:
                        DumpTypedef(parsedDeclaration);
                        break;
                }
            }
        }

        private static bool IsBaseType(string type)
        {
            return _baseTypes.ContainsKey(type);
        }

        private static bool IsVoid(string type)
        {
            return type == "void";
        }

        private static void DumpClientStubMethods(ParsedVersionInfo versionInfo)
        {
            foreach (ParsedProcedureInfo proc in versionInfo.Procedures)
            {
                int parametersCount = proc.Parameters.Count;
                string paramClassName = "";
                ParameterKind parameterKind;
                if (parametersCount > 1 || parametersCount == 0 || IsBaseType(proc.Parameters[0].DataType) || IsEnum(proc.Parameters[0].DataType))
                {
                    paramClassName = "Arguments_" + proc.ProcedureNumber;
                    DumpClientArgumentStruct(proc, paramClassName);
                    parameterKind = ParameterKind.More;
                }
                else
                {
                    paramClassName = proc.Parameters[0].DataType;
                    parameterKind = ParameterKind.Single;
                }

                string resultClassName;
                if (IsBaseType(proc.ResultType) || IsEnum(proc.ResultType))
                {
                    resultClassName = "Result_" + proc.ProcedureNumber;
                    DumpClientResultStruct(proc, resultClassName);
                }
                else
                {
                    resultClassName = proc.ResultType;
                }

                _outputFile.WriteLine();
                _outputFile.Write(
                    $"        public {CheckForSpecials(proc.ResultType)} {proc.ProcedureId}(");

                // If the remote procedure does not have any parameters, then parameters will be null. Otherwise it
                // contains a vector with information about the individual parameters, which we use in order to generate
                // the parameter list. Note that all parameters are named at this point (they will either have a user
                // supplied name, or an automatically generated one)
                if (parametersCount > 0)
                {
                    bool firstElement = true;
                    foreach (ParsedDeclaration parameter in proc.Parameters)
                    {
                        if (firstElement)
                        {
                            firstElement = false;
                        }
                        else
                        {
                            _outputFile.Write(", ");
                        }

                        _outputFile.Write(CheckForSpecials(parameter.DataType));
                        _outputFile.Write(" ");
                        _outputFile.Write(parameter.Identifier);
                    }
                }

                _outputFile.WriteLine(")");
                _outputFile.WriteLine("        {");

                string xdrParamsName;
                switch (parameterKind)
                {
                    case ParameterKind.Single:
                        {
                            ParsedDeclaration paramInfo = proc.Parameters[0];
                            xdrParamsName = paramInfo.Identifier;
                            // We do not need to emit an args_ declaration here, as we can immediately make use of the
                            // one and only argument the remote procedure expects
                            break;
                        }

                    default:
                        {
                            xdrParamsName = "args";
                            _outputFile.WriteLine($"            var args = new {paramClassName}();");
                            foreach (ParsedDeclaration parameter in proc.Parameters)
                            {
                                _outputFile.WriteLine($"            args.{parameter.Identifier} = {parameter.Identifier};");
                            }

                            break;
                        }
                }

                _outputFile.WriteLine($"            var result = new {resultClassName}();");

                // Now emit the real ONC/RPC call using the (optionally wrapped) parameter and (optionally wrapped)
                // result
                _outputFile.WriteLine(
                    $"            Call({ConstantsClassname}.{proc.ProcedureId}, {ConstantsClassname}.{versionInfo.VersionId}, {xdrParamsName}, result);");

                // In case of a wrapped result we need to return the value of the wrapper, otherwise we can return the
                // result itself (which then is not a base data type). As a special case, we can not return void
                // values...anyone for a language design with first class void objects?!
                if (IsBaseType(proc.ResultType))
                {
                    // Data type of result is a C# base data type, so we need to unwrap the XDR-able result -- if it's
                    // not a void, which we do not need to return at all
                    if (!IsVoid(proc.ResultType))
                    {
                        _outputFile.WriteLine("            return result.Value;");
                    }
                }
                else
                {
                    // Data type of result is a complex type (class), so we do not unwrap it but can return it
                    // immediately
                    _outputFile.WriteLine("            return result;");
                }

                // Close the stub method (just as a hint, as it is getting rather difficult to see what code is produced
                // at this stage...)
                _outputFile.WriteLine("        }");
            }
        }

        private static void DumpClientArgumentStruct(ParsedProcedureInfo proc, string paramClassName)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine("        private class " + paramClassName + " : IXdrWritable");
            _outputFile.WriteLine("        {");
            foreach (ParsedDeclaration paramInfo in proc.Parameters)
            {
                _outputFile.WriteLine(
                    $"            public {CheckForSpecials(paramInfo.DataType)} {paramInfo.Identifier};");
            }

            if (proc.Parameters.Count > 0)
            {
                _outputFile.WriteLine();
            }

            _outputFile.WriteLine("            public void WriteTo(IXdrWriter writer)");
            _outputFile.WriteLine("            {");
            // Emit serialization code for all parameters. Note that not we do not need to deal with all kinds
            // of parameters here, as things like "int<5>" are invalid, a typedef declaration is then necessary
            foreach (ParsedDeclaration paramInfo in proc.Parameters)
            {
                _outputFile.Write("        ");
                _outputFile.Write(CodingMethod(paramInfo, true));
            }

            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("        }");
        }

        private static void DumpClientResultStruct(ParsedProcedureInfo proc, string resultClassName)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine("        private class " + resultClassName + " : IXdrReadable");
            _outputFile.WriteLine("        {");
            if (!IsVoid(proc.ResultType))
            {
                _outputFile.WriteLine(
                    $"            public {CheckForSpecials(proc.ResultType)} Value;");
                _outputFile.WriteLine();
            }

            _outputFile.WriteLine("            public void ReadFrom(IXdrReader reader)");
            _outputFile.WriteLine("            {");
            if (!IsVoid(proc.ResultType))
            {
                _outputFile.Write("        ");
                _outputFile.Write(CodingMethod(new ParsedDeclaration("Value", proc.ResultType), false));
            }

            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("        }");
        }

        private static void DumpClient(ParsedProgramInfo programInfo)
        {
            // When several versions of a program are defined, we search for the latest and greatest one. This highest
            // version number ist then used to create the necessary RpcClient for communication when the
            // client proxy stub is constructed
            ParsedVersionInfo version = programInfo.Versions[0];
            int versionNumber = int.Parse(version.VersionNumber);
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                int anotherVersion = int.Parse(versionInfo.VersionNumber);
                if (anotherVersion > versionNumber)
                {
                    versionNumber = anotherVersion;
                    version = versionInfo;
                }
            }

            // Create new source code file containing a C# class representing the XDR struct. In case we have several
            // programs defines, build the source code file name from the program's name (this case is identified by a
            // null clientClass name)
            string clientClass = BaseClassname + "Client";

            _outputFile.WriteLine();

            _outputFile.WriteLine($"    internal class {clientClass} : ClientStub");
            _outputFile.WriteLine("    {");
            _outputFile.WriteLine(
                $"        public {clientClass}(Protocol protocol, IPAddress ipAddress, int port = 0) :");
            _outputFile.WriteLine($"            base(protocol, ipAddress, port, {ConstantsClassname}.{programInfo.ProgramId}, {ConstantsClassname}.{version.VersionId})");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("        }");

            // Generate method stubs... This is getting hairy in case someone uses basic data types as parameters or the
            // procedure's result. In these cases we need to encapsulate these basic data types in XDR-able data types
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                DumpClientStubMethods(versionInfo);
            }

            _outputFile.WriteLine("    }");
        }

        private static void DumpServerArgumentStruct(ParsedProcedureInfo proc)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        private class Arguments_{proc.ProcedureNumber} : IXdrReadable");
            _outputFile.WriteLine("        {");
            foreach (ParsedDeclaration parameter in proc.Parameters)
            {
                _outputFile.WriteLine(
                    $"            public {CheckForSpecials(parameter.DataType)} {parameter.Identifier};");
            }

            if (proc.Parameters.Count > 0)
            {
                _outputFile.WriteLine();
            }

            _outputFile.WriteLine("            public void ReadFrom(IXdrReader reader)");
            _outputFile.WriteLine("            {");

            // Emit serialization code for all parameters. Note that not we do not need to deal with all kinds
            // of parameters here, as things like "int<5>" are invalid, a typedef declaration is then necessary
            foreach (ParsedDeclaration parameter in proc.Parameters)
            {
                _outputFile.Write("        " + CodingMethod(parameter, false));
            }

            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("        }");
        }

        private static void DumpServerResultStruct(ParsedProcedureInfo proc)
        {
            _outputFile.WriteLine();
            _outputFile.WriteLine($"        private class Result_{proc.ProcedureNumber} : IXdrWritable");
            _outputFile.WriteLine("        {");
            if (!IsVoid(proc.ResultType))
            {
                _outputFile.WriteLine(
                    $"            public {CheckForSpecials(proc.ResultType)} Value;");
                _outputFile.WriteLine();
            }

            _outputFile.WriteLine("            public void WriteTo(IXdrWriter writer)");
            _outputFile.WriteLine("            {");
            if (!IsVoid(proc.ResultType))
            {
                _outputFile.Write("        ");
                _outputFile.Write(CodingMethod(new ParsedDeclaration("Value", proc.ResultType), true));
            }

            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("        }");
        }

        private static void DumpServerStubMethodCall(ParsedProcedureInfo proc)
        {
            // Check for special return types, like enumerations, which we map to their corresponding C# base data type
            string resultType = CheckForSpecials(proc.ResultType);

            // If the remote procedure does not have any parameters, then parameters will be null. Otherwise it contains
            // a vector with information about the individual parameters, which we use in order to generate the
            // parameter list. Note that all parameters are named at this point (they will either have a user supplied
            // name, or an automatically generated one)
            ParameterKind paramsKind;
            int parametersCount = proc.Parameters.Count;

            // Now find out what kind of parameter(s) we have. In case the remote procedure only expects a single
            // parameter, check whether it is a base type. In this case we later need to wrap the single parameter.
            // If the remote procedure expects more than a single parameter, then we always need a XDR wrapper
            if (parametersCount > 1)
            {
                paramsKind = ParameterKind.More;
            }
            else if (parametersCount == 0)
            {
                paramsKind = ParameterKind.Void;
            }
            else
            {
                // parametersCount must be equal to one, otherwise proc.parameters must have been null
                string firstParamType = proc.Parameters[0].DataType;
                paramsKind = XdrBaseType(CheckForSpecials(firstParamType)) == null
                    ? ParameterKind.Single
                    : ParameterKind.SingleBaseType;
            }

            // Do generate code for unwrapping here, if necessary
            string @params = string.Empty;
            switch (paramsKind)
            {
                case ParameterKind.Single:
                    {
                        // Only a single parameter, which is in addition immediately ready for serialization
                        ParsedDeclaration paramInfo = proc.Parameters[0];
                        _outputFile.WriteLine(
                            $"                        var args = new {paramInfo.DataType}();");
                        _outputFile.WriteLine("                        call.RetrieveCall(args);");
                        @params = "call.RemoteIpEndPoint, args";
                        break;
                    }

                default:
                    {
                        // We only need to refer to the struct here, we don't declare it as that isn't valid C# syntax
                        _outputFile.WriteLine(
                            $"                        var args = new Arguments_{proc.ProcedureNumber}();");
                        _outputFile.WriteLine("                        call.RetrieveCall(args);");
                        var paramsBuff = new StringBuilder();
                        paramsBuff.Append("call.RemoteIpEndPoint");

                        foreach (ParsedDeclaration parameter in proc.Parameters)
                        {
                            paramsBuff.Append(", args.");
                            paramsBuff.Append(parameter.Identifier);
                        }

                        @params = paramsBuff.ToString();
                        break;
                    }
            }

            // Check the return data type of the result to be of one of the base data types, like int, boolean, etc. In
            // this case we have to unwrap the result from one of the special XDR wrapper classes and return the base
            // data type instead
            if (IsVoid(resultType))
            {
                // It's a remote procedure, so it does return simply nothing. We use the singleton Void to return a
                // "nothing"
                _outputFile.WriteLine($"                        {proc.ProcedureId}({@params});");
                _outputFile.WriteLine($"                        call.Reply(new Result_{proc.ProcedureNumber}());");
            }
            else if (IsBaseType(resultType))
            {
                // The return type is some C# base data type, so we need to wrap the return value before we can
                // serialize it
                _outputFile.WriteLine($"                        var result = new Result_{proc.ProcedureNumber}();");
                _outputFile.WriteLine($"                        result.Value = {proc.ProcedureId}({@params});");
                _outputFile.WriteLine("                        call.Reply(result);");
            }
            else
            {
                // The return type is a complex type which supports IXdrAble
                _outputFile.WriteLine($"                        var result = {proc.ProcedureId}({@params});");
                _outputFile.WriteLine("                        call.Reply(result);");
            }
        }

        private static void DumpServerStubMethods(ParsedVersionInfo versionInfo)
        {
            foreach (ParsedProcedureInfo procedure in versionInfo.Procedures)
            {
                string resultType = CheckForSpecials(procedure.ResultType);
                _outputFile.Write($"        public abstract {resultType} {procedure.ProcedureId}(IPEndPoint remoteIpEndPoint");
                foreach (ParsedDeclaration parameter in procedure.Parameters)
                {
                    _outputFile.Write(", ");
                    _outputFile.Write(CheckForSpecials(parameter.DataType));
                    _outputFile.Write(" ");
                    _outputFile.Write(parameter.Identifier);
                }

                _outputFile.WriteLine(");");
            }
        }

        private static void DumpServer(ParsedProgramInfo programInfo)
        {
            string serverClass = BaseClassname + "ServerStub";

            string versions = string.Join(", ", programInfo.Versions.Select(version => ConstantsClassname + "." + version.VersionId));

            _outputFile.WriteLine();
            _outputFile.WriteLine($"    internal abstract class {serverClass} : ServerStub");
            _outputFile.WriteLine("    {");
            _outputFile.WriteLine($"        public {serverClass}(IPAddress ipAddress, int port = 0) :");
            _outputFile.WriteLine(
                $"            base(ipAddress, port, {ConstantsClassname}.{programInfo.ProgramId}, new[] {{ {versions} }})");
            _outputFile.WriteLine("        {");
            _outputFile.WriteLine("        }");

            // First we need to create all the structs so that they are outside member function scope for C#.
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                foreach (ParsedProcedureInfo procedure in versionInfo.Procedures)
                {
                    if (procedure.Parameters.Count == 0 || procedure.Parameters.Count > 1 || IsBaseType(procedure.Parameters[0].DataType) || IsEnum(procedure.Parameters[0].DataType))
                    {
                        DumpServerArgumentStruct(procedure);
                    }

                    if (IsBaseType(procedure.ResultType) || IsEnum(procedure.ResultType))
                    {
                        DumpServerResultStruct(procedure);
                    }
                }
            }

            // Now generate dispatcher code using the previously generated structs where applicable
            _outputFile.WriteLine();
            _outputFile.WriteLine(
                "        protected override void DispatchReceivedCall(ReceivedCall call)");
            _outputFile.WriteLine("        {");
            bool first = true;
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                if (first)
                {
                    first = false;
                    _outputFile.WriteLine($"            if (call.Version == {ConstantsClassname}.{versionInfo.VersionId})");
                    _outputFile.WriteLine("            {");
                }
                else
                {
                    _outputFile.WriteLine("            }");
                    _outputFile.WriteLine($"            else if (call.Version == {ConstantsClassname}.{versionInfo.VersionId})");
                    _outputFile.WriteLine("            {");
                }

                _outputFile.WriteLine("                switch (call.Procedure)");
                _outputFile.WriteLine("                {");
                foreach (ParsedProcedureInfo procInfo in versionInfo.Procedures)
                {
                    // Emit case arms for every procedure defined. We have to take care that the procedure number might
                    // be a constant coming from an enumeration: in this case we need also to dump the enclosure
                    _outputFile.WriteLine($"                    case {ConstantsClassname}.{procInfo.ProcedureId}:");
                    _outputFile.WriteLine("                    {");
                    DumpServerStubMethodCall(procInfo);
                    _outputFile.WriteLine("                        break;");
                    _outputFile.WriteLine("                    }");
                }

                _outputFile.WriteLine("                    default:");
                _outputFile.WriteLine("                        call.ProcedureUnavailable();");
                _outputFile.WriteLine("                        break;");
                _outputFile.WriteLine("                }");
            }

            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("            else");
            _outputFile.WriteLine("            {");
            _outputFile.WriteLine("                call.ProgramMismatch();");
            _outputFile.WriteLine("            }");
            _outputFile.WriteLine("        }");
            _outputFile.WriteLine();
            // Generate the abstract stub methods for all specified remote procedures.
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                DumpServerStubMethods(versionInfo);
            }

            _outputFile.WriteLine("    }");
        }

        private static void DumpFiles()
        {
            DumpConstants();
            DumpClasses();
            foreach (ParsedProgramInfo programInfo in _programInfos)
            {
                DumpClient(programInfo);
                DumpServer(programInfo);
            }
        }

        private static void Main(string[] args)
        {
            // First parse the command line (options)...
            int argc = args.Length;
            int argIdx = 0;
            for (; argIdx < argc; ++argIdx)
            {
                // Check to see whether this is an option...
                string arg = args[argIdx].ToLower();
                if (arg.Length > 0 && arg[0] != '-')
                {
                    break;
                }

                switch (arg)
                {
                    case "-o":
                        // -o <output file>
                        if (++argIdx >= argc)
                        {
                            Console.WriteLine("RpcNetGen: missing output file");
                            Environment.Exit(1);
                        }

                        _outputFilePath = Path.GetFullPath(args[argIdx]);
                        break;
                    case "-n":
                        // -n <namespace>
                        if (++argIdx >= argc)
                        {
                            Console.WriteLine("RpcNetGen: missing namespace");
                            Environment.Exit(1);
                        }

                        _namespace = args[argIdx];
                        break;
                    case "-version":
                        Console.WriteLine("RpcNetGen version \"" + Version + "\"");
                        Environment.Exit(1);
                        break;
                    case "-help":
                    case "-?":
                        PrintHelp();
                        Environment.Exit(1);
                        break;
                    default:
                        // It's an unknown option!
                        Console.WriteLine("Unrecognized option: " + arg);
                        Environment.Exit(1);
                        break;
                }
            }

            // Otherwise we regard the current command line argument to be the name of the x-file to compile. Check,
            // that there is exactly one x-file specified
            if (argIdx >= argc || argIdx < argc - 1)
            {
                PrintHelp();
                Environment.Exit(1);
            }

            _inputFilePath = Path.GetFullPath(args[argIdx]);
            BaseClassname = Path.GetFileNameWithoutExtension(_inputFilePath);
            ConstantsClassname = BaseClassname + "Constants";
            if (string.IsNullOrWhiteSpace(_outputFilePath))
            {
                string directoryName = Path.GetDirectoryName(_inputFilePath);
                _outputFilePath = Path.Combine(directoryName, BaseClassname + ".cs");
            }

            // Try to parse the file and generate the different class source code files...
            try
            {
                DoParse();
            }
            catch (Exception t)
            {
                Console.WriteLine(t);
                Environment.Exit(1);
            }
        }

        private static void DoParse()
        {
            StreamReader @in;
            try
            {
                @in = new StreamReader(_inputFilePath);
            }
            catch (FileNotFoundException)
            {
                throw new FileNotFoundException(
                    $"RpcNetGen: can not open source x-file \"{Path.GetFullPath(_inputFilePath)}\"");
            }

            var scanner = new Scanner(@in);
            var parser = new Parser(scanner);
            GlobalIdentifiers["TRUE"] = new ParsedConst("TRUE", "true");
            GlobalIdentifiers["FALSE"] = new ParsedConst("FALSE", "false");
            try
            {
                parser.parse();
                CreateSourceFile();
                DumpFiles();
                CloseSourceFile();
            }
            catch (ParserException pe)
            {
                throw new Exception("RpcNetGen: compilation aborted (" + pe.Message + ")");
            }
        }

        private static bool IsEnum(string identifier)
        {
            return GlobalIdentifiers.TryGetValue(identifier, out ParsedElementBase element) && element is ParsedEnum;
        }

        private enum ParameterKind
        {
            Void,
            Single,
            SingleBaseType,
            More
        }

        private class WriteReadOptions
        {
            public WriteReadOptions(string writeFunction, string readFunction, string writeAppendix, string readAppendix, bool isEnum)
            {
                WriteFunction = writeFunction;
                ReadFunction = readFunction;
                WriteAppendix = writeAppendix ?? string.Empty;
                ReadAppendix = readAppendix ?? string.Empty;
                IsEnum = isEnum;
            }

            public string WriteFunction { get; }
            public string ReadFunction { get; }
            public string WriteAppendix { get; }
            public string ReadAppendix { get; }
            public bool IsEnum { get; }
        }
    }
}

namespace RpcNetGen
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;

    internal static class Program
    {
        private const string Version = "1.0.0";

        public static readonly Dictionary<string, ParsedElementBase> GlobalIdentifiers = new Dictionary<string, ParsedElementBase>();

        public static string BaseClassname;
        public static string ConstantsClassname;

        private static readonly Dictionary<string, string> BaseTypes = new Dictionary<string, string>
        {
            { "void", "Void" },
            { "bool", "Bool" },
            { "byte", "Byte" },
            { "short", "Short" },
            { "ushort", "UShort" },
            { "int", "Int" },
            { "uint", "UInt" },
            { "long", "Long" },
            { "ulong", "ULong" },
            { "float", "Float" },
            { "double", "Double" },
            { "string", "String" }
        };

        private static string inputFilePath;
        private static string @namespace;
        private static StreamWriter outputFile;
        private static string outputFilePath;

        private static List<ParsedProgramInfo> programInfos;

        public static void SetProgramInfos(IEnumerable programInfos) => Program.programInfos = programInfos.Cast<ParsedProgramInfo>().ToList();

        public static void AddElement(string id, ParsedElementBase element)
        {
            if (GlobalIdentifiers.ContainsKey(id))
            {
                Console.WriteLine($"ID {id} is already defined.");
                Environment.Exit(1);
            }

            GlobalIdentifiers.Add(id, element);
        }

        private static void PrintHelp()
        {
            Console.WriteLine("Usage: RpcNetGen [-options] x-file");
            Console.WriteLine();
            Console.WriteLine("where options include:");
            Console.WriteLine("  -o <output file> specify output file");
            Console.WriteLine("  -n <namespace>   specify namespace for output file");
            Console.WriteLine("  -? -help         print this help message and exit");
            Console.WriteLine();
        }

        private static void CreateSourceFile()
        {
            outputFile = new StreamWriter(outputFilePath);

            outputFile.Write("//------------------------------------------------------------------------------\n");
            outputFile.Write("// <auto-generated>\n");
            outputFile.Write($"//     This code was generated by RpcNetGen {Version}.\n");
            outputFile.Write("//\n");
            outputFile.Write("//     Changes to this file may cause incorrect behavior and will be lost if\n");
            outputFile.Write("//     the code is regenerated.\n");
            outputFile.Write("// </auto-generated>\n");
            outputFile.Write("//------------------------------------------------------------------------------\n");
            outputFile.Write("\n");

            if (!string.IsNullOrWhiteSpace(@namespace))
            {
                outputFile.Write($"namespace {@namespace}\n");
                outputFile.Write("{\n");
            }

            outputFile.Write("    using System;\n");
            outputFile.Write("    using System.Net;\n");
            outputFile.Write("    using RpcNet;\n");
        }

        private static void CloseSourceFile()
        {
            if (!string.IsNullOrWhiteSpace(@namespace))
            {
                outputFile.Write("}\n");
            }

            outputFile.Dispose();
        }

        private static void DumpConstantAndDependency(ParsedConst c)
        {
            // This simple test avoids endless recursions: we already dumped this particular constant in some place, so
            // we should not proceed
            if (c.DoNotTraverseAnyMore)
            {
                return;
            }

            // Since we will dump the constant below, we already set the flag, to avoid endless recursions
            c.DoNotTraverseAnyMore = true;
            if (c.DependencyIdentifier != null)
            {
                // There is a dependency, so try to resolve that first. In case we depend on another identifier
                // belonging to the same enclosure, we dump this other identifier first. However, if the identifier we
                // depend on belongs to a different enclosure, then we must not dump it: this will be the job of a later
                // call when the proper enclosure is in the works
                if (GlobalIdentifiers.TryGetValue(c.DependencyIdentifier, out ParsedElementBase value) && value is ParsedConst dc)
                {
                    if (!c.Enclosure.Equals(dc.Enclosure, StringComparison.OrdinalIgnoreCase))
                    {
                        // In case we depend on a constant which belongs to a different enclosure then also dump the
                        // enclosure. Note that this code depends on the "value"
                        // starts with the identifier we depend on (which is currently the case), so we just need to
                        // prepend the enclosure
                        outputFile.Write($"        public const int {c.Identifier} = {dc.Enclosure}.{c.Value};\n");
                        return;
                    }

                    // Only dump the identifier we're dependent on, if it's in the same enclosure
                    DumpConstantAndDependency(dc);
                }
            }

            // Just dump the plain value (without enclosure)
            outputFile.Write($"        public const int {c.Identifier} = {c.Value};\n");
        }

        private static void DumpConstants()
        {
            outputFile.Write("\n");
            outputFile.Write("    internal static class " + ConstantsClassname + "\n");
            outputFile.Write("    {\n");
            foreach (ParsedElementBase parsedElement in GlobalIdentifiers.Values)
            {
                if (parsedElement is ParsedConst parsedConst)
                {
                    // Dump only such constants which belong to the global constants enclosure. Ignore all other
                    // constants, as those belong to other C# class enclosures
                    if (BaseClassname.Equals(parsedConst.Enclosure))
                    {
                        DumpConstantAndDependency(parsedConst);
                    }
                }
            }

            outputFile.Write("    }\n");
        }

        private static void DumpEnum(ParsedEnum e)
        {
            outputFile.Write("\n");
            outputFile.Write($"    internal enum {e.Identifier}\n");
            outputFile.Write("    {\n");
            foreach (ParsedConst enumElement in e.EnumElements)
            {
                outputFile.Write($"        {enumElement.Identifier} = {enumElement.Value},\n");
            }

            outputFile.Write("    }\n");
        }

        private static string XdrBaseType(string type)
        {
            if (type == "opaque")
            {
                type = "byte";
            }
            else if (type == "bool")
            {
                return "XdrBool";
            }

            if (BaseTypes.TryGetValue(type, out string baseType))
            {
                return "Xdr" + baseType;
            }

            return null;
        }

        private static WriteReadOptions BaseEnDecodingSyllable(ParsedDeclaration decl)
        {
            string writeFunction = "Write";
            string readFunction = "Read" + decl.DataType;
            bool isBase = false;

            // Check for C# base data types... if a match is found, then convert the data type name, so that it
            // becomes a valid syllable for use with XDR en-/decoding functions XdrEncodingXXX() etc. Example: "int" -->
            // "Int" (because of XdrEncodingInt()) NOTE: we consider "opaque" to be a base type here...
            string type = decl.DataType;
            if (type == "opaque")
            {
                type = "byte";
            }

            if (BaseTypes.TryGetValue(type, out string baseType))
            {
                isBase = true;
                readFunction = "Read" + baseType;
            }

            bool isEnum = false;

            // Handle special case of enumerations, which have to be represented using integers in the C# language.
            if (!isBase && GlobalIdentifiers.TryGetValue(decl.DataType, out ParsedElementBase o) && o is ParsedEnum)
            {
                isBase = true;
                isEnum = true;
                readFunction = "ReadInt";
            }

            if (!isBase)
            {
                return null;
            }

            string writeAppendix = null;
            string readAppendix = null;
            if ((decl.Kind == DeclarationType.FixedVector) || (decl.Kind == DeclarationType.DynamicVector))
            {
                if (decl.DataType == "opaque")
                {
                    if (decl.Kind == DeclarationType.FixedVector)
                    {
                        readAppendix = CheckForConstant(decl.Size);
                        writeFunction = "WriteFixedLengthOpaque";
                    }
                    else
                    {
                        writeFunction = "WriteVariableLengthOpaque";
                    }

                    readFunction = "ReadOpaque";
                }
                else if (decl.DataType != "string")
                {
                    if (decl.Kind == DeclarationType.FixedVector)
                    {
                        readAppendix = CheckForConstant(decl.Size);
                        writeFunction = "WriteFixedLengthArray";
                    }
                    else
                    {
                        writeFunction = "WriteVariableLengthArray";
                    }

                    readFunction += "Array";
                }
            }

            return new WriteReadOptions(writeFunction, readFunction, writeAppendix, readAppendix, isEnum);
        }

        private static string CodingMethod(ParsedDeclaration decl, bool encode, string outerRef = null)
        {
            // Skip entries for void arms etc...
            if (decl.Identifier == null)
            {
                return string.Empty;
            }

            WriteReadOptions data = BaseEnDecodingSyllable(decl);

            string identifier = decl.Identifier;
            if (!string.IsNullOrWhiteSpace(outerRef))
            {
                identifier = outerRef + "." + identifier;
            }

            if (data?.IsEnum == true)
            {
                if (decl.Kind == DeclarationType.Scalar)
                {
                    return encode ? EncodeScalarEnum(data, identifier) : DecodeScalarEnum(decl, identifier, data);
                }

                return encode ? EncodeVectorEnum(decl, identifier) : DecodeVectorEnum(decl, identifier);
            }

            if (data != null)
            {
                return encode ? EncodeScalarBaseType(data, identifier) : DecodeScalarBaseType(identifier, data, decl.Kind == DeclarationType.FixedVector);
            }

            if (decl.Kind == DeclarationType.Scalar)
            {
                return encode ? EncodeScalar(identifier) : DecodeScalar(decl, identifier);
            }

            if (decl.Kind == DeclarationType.Indirection)
            {
                return encode ? EncodeIndirection(identifier) : DecodeIndirection(decl, identifier);
            }

            return encode ? EncodeVector(decl, identifier) : DecodeVector(decl, identifier);
        }

        private static string EncodeScalarEnum(WriteReadOptions data, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        writer.");
            code.Append(data.WriteFunction);
            code.Append("((int)");
            code.Append(identifier);
            code.Append(data.WriteAppendix);
            code.Append(");\n");
            return code.ToString();
        }

        private static string DecodeScalarEnum(ParsedDeclaration decl, string identifier, WriteReadOptions data)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = (");
            code.Append(decl.DataType);
            code.Append(")reader.");
            code.Append(data.ReadFunction);
            code.Append("(");
            code.Append(data.ReadAppendix);
            code.Append(");\n");
            return code.ToString();
        }

        private static string EncodeVectorEnum(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                code.Append(identifier);
                code.Append("?.Length ?? 0");
            }
            else
            {
                code.Append(CheckForConstant(decl.Size));
            }

            code.Append("; ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                code.Append("writer.Write(_size); ");
            }

            code.Append("for (int _idx = 0; _idx < _size; _idx++) { writer.Write((int)");
            code.Append(identifier);
            code.Append("[_idx]); } }\n");
            return code.ToString();
        }

        private static string DecodeVectorEnum(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            code.Append(decl.Kind == DeclarationType.DynamicVector ? "reader.ReadInt()" : CheckForConstant(decl.Size));

            code.Append("; ");
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.Append("[_size]; for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.Append("[_idx] = (");
            code.Append(decl.DataType);
            code.Append(")reader.ReadInt(); } }\n");
            return code.ToString();
        }

        private static string EncodeScalarBaseType(WriteReadOptions data, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        writer.");
            code.Append(data.WriteFunction);
            code.Append("(");
            code.Append(identifier);
            code.Append(data.WriteAppendix);
            code.Append(");\n");
            return code.ToString();
        }

        private static string DecodeScalarBaseType(string identifier, WriteReadOptions data, bool isFixedVector)
        {
            if (isFixedVector)
            {
                var code = new StringBuilder();
                code.Append("        ");
                code.Append("reader.");
                code.Append(data.ReadFunction);
                code.Append("(");
                code.Append(identifier);
                code.Append(");\n");
                return code.ToString();
            }
            else
            {
                var code = new StringBuilder();
                code.Append("        ");
                code.Append(identifier);
                code.Append(" = reader.");
                code.Append(data.ReadFunction);
                code.Append("(");
                code.Append(data.ReadAppendix);
                code.Append(");\n");
                return code.ToString();
            }
        }

        private static string EncodeScalar(string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append("?.WriteTo(writer);\n");
            return code.ToString();
        }

        private static string DecodeScalar(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.Append("(reader);\n");
            return code.ToString();
        }

        private static string EncodeIndirection(string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append("if (");
            code.Append(identifier);
            code.Append(" != null) { writer.Write(true); ");
            code.Append(identifier);
            code.Append(".WriteTo(writer); } else { writer.Write(false); }\n");
            return code.ToString();
        }

        private static string DecodeIndirection(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        ");
            code.Append(identifier);
            code.Append(" = read.ReadBool() ? new ");
            code.Append(decl.DataType);
            code.Append("(reader) : null;\n");
            return code.ToString();
        }

        private static string EncodeVector(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                // Dynamic array size. So we need to use the current size of the C# array
                code.Append(identifier);
                code.Append("?.Length ?? 0");
            }
            else
            {
                code.Append(CheckForConstant(decl.Size));
            }

            code.Append("; ");
            if (decl.Kind == DeclarationType.DynamicVector)
            {
                // Dynamic array size. So we need to encode size information
                code.Append("writer.Write(_size); ");
            }

            // Now encode all elements
            code.Append("for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.Append("[_idx].WriteTo(writer); } }\n");
            return code.ToString();
        }

        private static string DecodeVector(ParsedDeclaration decl, string identifier)
        {
            var code = new StringBuilder();
            code.Append("        { int _size = ");
            code.Append(decl.Kind == DeclarationType.DynamicVector ? "reader.ReadInt()" : CheckForConstant(decl.Size));

            code.Append("; ");

            // Now encode all elements
            code.Append(identifier);
            code.Append(" = new ");
            code.Append(decl.DataType);
            code.Append("[_size]; for (int _idx = 0; _idx < _size; _idx++) { ");
            code.Append(identifier);
            code.Append("[_idx] = new ");
            code.Append(decl.DataType);
            code.Append("(reader); } }\n");
            return code.ToString();
        }

        private static string CheckForSpecials(string dataType) => "opaque".Equals(dataType) ? "byte" : dataType;

        private static string CheckForConstant(string value)
        {
            if (value.Length > 0)
            {
                // If the value is an integer literal, then we just have to return it
                if (char.IsDigit(value[0]) || (value[0] == '-'))
                {
                    return value;
                }

                // It's an identifier: we now need to find out in which enclosure it lives, so we can return a qualified
                // identifier
                ParsedElementBase id = GlobalIdentifiers[value];
                if (id is ParsedConst c)
                {
                    return c.Enclosure == null ? c.Value : c.Enclosure + "." + c.Identifier;
                }
            }

            return value;
        }

        private static void DumpStruct(ParsedStruct s)
        {
            outputFile.Write("\n");
            outputFile.Write($"    internal partial class {s.Identifier} : IXdrReadable, IXdrWritable\n");
            outputFile.Write("    {\n");

            // Generate declarations of all members of this XDR struct. This the perfect place to also update the hash
            // function using the elements together with their type
            bool useIteration = false;
            for (int i = 0; i < s.Elements.Count; i++)
            {
                ParsedDeclaration d = s.Elements[i];
                outputFile.Write($"        public {CheckForSpecials(d.DataType)}");
                if (((d.Kind == DeclarationType.FixedVector) || (d.Kind == DeclarationType.DynamicVector)) && !d.DataType.Equals("string"))
                {
                    outputFile.Write("[]");
                }

                if (d.Kind == DeclarationType.FixedVector)
                {
                    outputFile.Write($" {d.Identifier} {{ get; }} = new {CheckForSpecials(d.DataType)}[{d.Size}];");
                }
                else
                {
                    outputFile.Write($" {d.Identifier} {{ get; set; }}");
                }

                if (d.DataType.Equals("string"))
                {
                    outputFile.Write(" = \"\";");
                }

                outputFile.Write("\n");

                // If the last element in the XDR struct is a reference to the type of the XDR struct (that is, a linked
                // list), then we can convert this tail recursion into an iteration, avoiding deep recursions for large
                // lists
                if ((i == (s.Elements.Count - 1)) && (d.Kind == DeclarationType.Indirection) && d.DataType.Equals(s.Identifier))
                {
                    useIteration = true;
                }
            }

            // Now generate code for encoding and decoding this class (structure).
            outputFile.Write("\n");
            outputFile.Write($"        public {s.Identifier}()\n");
            outputFile.Write("        {\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write($"        public {s.Identifier}(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            outputFile.Write("            ReadFrom(reader);\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void WriteTo(IXdrWriter writer)\n");
            outputFile.Write("        {\n");
            if (useIteration)
            {
                outputFile.Write("            var current = this;\n");
                outputFile.Write("            do\n");
                outputFile.Write("            {\n");

                for (int i = 0; i < (s.Elements.Count - 1); i++)
                {
                    outputFile.Write("        " + CodingMethod(s.Elements[i], true, "current"));
                }

                outputFile.Write($"                current = current.{s.Elements[^1].Identifier};\n");
                outputFile.Write("                writer.Write(current != null);\n");
                outputFile.Write("            } while (current != null);\n");
            }
            else
            {
                foreach (ParsedDeclaration declaration in s.Elements)
                {
                    outputFile.Write("    " + CodingMethod(declaration, true));
                }
            }

            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void ReadFrom(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            if (useIteration)
            {
                outputFile.Write("            var current = this;\n");
                outputFile.Write($"            {s.Identifier} next;\n");
                outputFile.Write("            do\n");
                outputFile.Write("            {\n");

                for (int i = 0; i < (s.Elements.Count - 1); i++)
                {
                    outputFile.Write("        " + CodingMethod(s.Elements[i], false, "current"));
                }

                outputFile.Write($"                next = reader.ReadBool() ? new {s.Identifier}() : null;\n");
                outputFile.Write($"                current.{s.Elements[^1].Identifier} = next;\n");
                outputFile.Write("                current = next;\n");
                outputFile.Write("            } while (current != null);\n");
            }
            else
            {
                foreach (ParsedDeclaration declaration in s.Elements)
                {
                    outputFile.Write("    " + CodingMethod(declaration, false));
                }
            }

            outputFile.Write("        }\n");
            outputFile.Write("    }\n");
        }

        private static void DumpUnion(ParsedUnion u)
        {
            outputFile.Write("\n");
            outputFile.Write($"    internal partial class {u.Identifier} : IXdrReadable, IXdrWritable\n");
            outputFile.Write("    {\n");

            // Note that the descriminant can not be of an array type, string, etc. so we don't have to handle all the
            // special cases here
            outputFile.Write($"        public {CheckForSpecials(u.Descriminant.DataType)} {u.Descriminant.Identifier} {{ get; set; }}\n");
            bool boolDescriminant = u.Descriminant.DataType.Equals("bool");
            foreach (ParsedUnionArm unionArm in u.Elements)
            {
                // Skip all arms which do not contain a variable but are declared as "void" instead. Also skip all arms
                // which are mapped to another arm
                if (unionArm.Element?.Identifier == null)
                {
                    continue;
                }

                outputFile.Write("        public " + CheckForSpecials(unionArm.Element.DataType));
                if (((unionArm.Element.Kind == DeclarationType.FixedVector) || (unionArm.Element.Kind == DeclarationType.DynamicVector)) &&
                    (unionArm.Element.DataType != "string"))
                {
                    outputFile.Write("[]");
                }

                outputFile.Write($" {unionArm.Element.Identifier} {{ get; set; }}\n");
            }

            // Now generate code for encoding and decoding this class (structure).
            outputFile.Write("\n");
            outputFile.Write($"        public {u.Identifier}()\n");
            outputFile.Write("        {\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write($"        public {u.Identifier}(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            outputFile.Write("            ReadFrom(reader);\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void WriteTo(IXdrWriter writer)\n");
            outputFile.Write("        {\n");
            outputFile.Write("    " + CodingMethod(u.Descriminant, true));
            if (!boolDescriminant)
            {
                // Produce code using an ordinary switch statement...
                outputFile.Write($"            switch ({u.Descriminant.Identifier})\n");
                outputFile.Write("            {\n");
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    outputFile.Write(unionArm.Value != null ? $"                case {CheckForConstant(unionArm.Value)}:\n" : "                default:\n");

                    // Only emit code if arm does not map to another arm.
                    if (unionArm.Element != null)
                    {
                        if (unionArm.Element.Identifier != null)
                        {
                            // Arm does not contain void, so we need to spit out encoding instructions.
                            outputFile.Write("            " + CodingMethod(unionArm.Element, true));
                        }

                        outputFile.Write("                    break;\n");
                    }
                }

                outputFile.Write("            }\n");
            }
            else
            {
                // boolean descriminant: here we can have at most two arms, guess why.
                bool firstArm = true;
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null)
                    {
                        // Skip default branch this time...
                        continue;
                    }

                    if (unionArm.Element.Identifier != null)
                    {
                        // Arm contains data, so we need to create encoding instructions.
                        outputFile.Write("        ");
                        if (!firstArm)
                        {
                            outputFile.Write("else ");
                        }
                        else
                        {
                            firstArm = false;
                        }

                        outputFile.Write($"if ({u.Descriminant.Identifier} == {CheckForConstant(unionArm.Value)}) {{\n");
                        outputFile.Write("    ");
                        outputFile.Write(CodingMethod(unionArm.Element, true));
                        outputFile.Write("        }\n");
                    }
                }

                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if ((unionArm.Value == null) && (unionArm.Element.Identifier != null))
                    {
                        outputFile.Write("        ");
                        if (!firstArm)
                        {
                            outputFile.Write("else ");
                        }

                        outputFile.Write("{\n");
                        outputFile.Write("    ");
                        outputFile.Write(CodingMethod(unionArm.Element, true));
                        outputFile.Write("        }\n");
                    }
                }
            }

            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void ReadFrom(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            outputFile.Write("    " + CodingMethod(u.Descriminant, false));
            if (!boolDescriminant)
            {
                // Produce code using an ordinary switch statement...
                outputFile.Write($"            switch ({u.Descriminant.Identifier})\n");
                outputFile.Write("            {\n");
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    outputFile.Write(unionArm.Value != null ? $"                case {CheckForConstant(unionArm.Value)}:\n" : "                default:\n");

                    // Only emit code if arm does not map to another arm.
                    if (unionArm.Element != null)
                    {
                        if (unionArm.Element.Identifier != null)
                        {
                            // Arm does not contain void, so we need to spit out encoding instructions.
                            outputFile.Write("            " + CodingMethod(unionArm.Element, false));
                        }

                        outputFile.Write("                    break;\n");
                    }
                }

                outputFile.Write("            }\n");
            }
            else
            {
                // boolean descriminant: here we can have at most two arms, guess why.
                bool firstArm = true;
                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if (unionArm.Value == null)
                    {
                        // Skip default branch this time...
                        continue;
                    }

                    if (unionArm.Element.Identifier != null)
                    {
                        // Arm contains data, so we need to create encoding instructions.
                        outputFile.Write("        ");
                        if (!firstArm)
                        {
                            outputFile.Write("else ");
                        }
                        else
                        {
                            firstArm = false;
                        }

                        outputFile.Write($"if ({u.Descriminant.Identifier} == {CheckForConstant(unionArm.Value)}) {{\n");
                        outputFile.Write("    ");
                        outputFile.Write(CodingMethod(unionArm.Element, false));
                        outputFile.Write("        }\n");
                    }
                }

                foreach (ParsedUnionArm unionArm in u.Elements)
                {
                    if ((unionArm.Value == null) && (unionArm.Element.Identifier != null))
                    {
                        outputFile.Write("        ");
                        if (!firstArm)
                        {
                            outputFile.Write("else ");
                        }

                        outputFile.Write("{\n");
                        outputFile.Write("    ");
                        outputFile.Write(CodingMethod(unionArm.Element, false));
                        outputFile.Write("        }\n");
                    }
                }
            }

            outputFile.Write("        }\n");
            outputFile.Write("    }\n");
        }

        private static void DumpTypedef(ParsedDeclaration d)
        {
            outputFile.Write("\n");
            outputFile.Write($"    internal partial class {d.Identifier} : IXdrReadable, IXdrWritable\n");
            outputFile.Write("    {\n");
            string paramType = CheckForSpecials(d.DataType);
            if (((d.Kind == DeclarationType.FixedVector) || (d.Kind == DeclarationType.DynamicVector)) && !d.DataType.Equals("string"))
            {
                paramType += " []";
            }

            outputFile.Write($"        public {paramType} Value {{ get; set; }}\n");

            // Now generate code for encoding and decoding this class (typedef).
            var declaration = new ParsedDeclaration("Value", d.DataType, d.Kind, d.Size);
            outputFile.Write("\n");
            outputFile.Write($"        public {d.Identifier}()\n");
            outputFile.Write("        {\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write($"        public {d.Identifier}({paramType} value)\n");
            outputFile.Write("        {\n");
            outputFile.Write("            Value = value;\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write($"        public {d.Identifier}(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            outputFile.Write("            ReadFrom(reader);\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void WriteTo(IXdrWriter writer)\n");
            outputFile.Write("        {\n");
            outputFile.Write("    " + CodingMethod(declaration, true));
            outputFile.Write("        }\n");
            outputFile.Write("\n");
            outputFile.Write("        public void ReadFrom(IXdrReader reader)\n");
            outputFile.Write("        {\n");
            outputFile.Write("    " + CodingMethod(declaration, false));
            outputFile.Write("        }\n");
            outputFile.Write("    }\n");
        }

        private static void DumpClasses()
        {
            foreach (ParsedElementBase parsedElement in GlobalIdentifiers.Values.OrderBy(v => v.Identifier))
            {
                switch (parsedElement)
                {
                    case ParsedEnum parsedEnum:
                        DumpEnum(parsedEnum);
                        break;
                    case ParsedStruct parsedStruct:
                        DumpStruct(parsedStruct);
                        break;
                    case ParsedUnion parsedUnion:
                        DumpUnion(parsedUnion);
                        break;
                    case ParsedDeclaration parsedDeclaration:
                        DumpTypedef(parsedDeclaration);
                        break;
                }
            }
        }

        private static bool IsBaseType(string type) => BaseTypes.ContainsKey(type);

        private static bool IsVoid(string type) => type == "void";

        private static void DumpClientStubMethods(ParsedVersionInfo versionInfo)
        {
            foreach (ParsedProcedureInfo proc in versionInfo.Procedures)
            {
                int parametersCount = proc.Parameters.Count;
                string paramClassName;
                ParameterKind parameterKind;
                if ((parametersCount > 1) || (parametersCount == 0) || IsBaseType(proc.Parameters[0].DataType) || IsEnum(proc.Parameters[0].DataType))
                {
                    paramClassName = "Arguments_" + proc.ProcedureNumber;
                    DumpClientArgumentStruct(proc, paramClassName);
                    parameterKind = ParameterKind.More;
                }
                else
                {
                    paramClassName = proc.Parameters[0].DataType;
                    parameterKind = ParameterKind.Single;
                }

                string resultClassName;
                if (IsBaseType(proc.ResultType) || IsEnum(proc.ResultType))
                {
                    resultClassName = "Result_" + proc.ProcedureNumber;
                    DumpClientResultStruct(proc, resultClassName);
                }
                else
                {
                    resultClassName = proc.ResultType;
                }

                outputFile.Write("\n");
                outputFile.Write($"        public {CheckForSpecials(proc.ResultType)} {proc.ProcedureId}(");

                // If the remote procedure does not have any parameters, then parameters will be null. Otherwise it
                // contains a vector with information about the individual parameters, which we use in order to generate
                // the parameter list. Note that all parameters are named at this point (they will either have a user
                // supplied name, or an automatically generated one)
                if (parametersCount > 0)
                {
                    bool firstElement = true;
                    foreach (ParsedDeclaration parameter in proc.Parameters)
                    {
                        if (firstElement)
                        {
                            firstElement = false;
                        }
                        else
                        {
                            outputFile.Write(", ");
                        }

                        outputFile.Write(CheckForSpecials(parameter.DataType));
                        outputFile.Write(" ");
                        outputFile.Write(parameter.Identifier);
                    }
                }

                outputFile.Write(")\n");
                outputFile.Write("        {\n");

                string xdrParamsName;
                switch (parameterKind)
                {
                    case ParameterKind.Single:
                    {
                        ParsedDeclaration paramInfo = proc.Parameters[0];
                        xdrParamsName = paramInfo.Identifier;

                        // We do not need to emit an args_ declaration here, as we can immediately make use of the
                        // one and only argument the remote procedure expects
                        break;
                    }

                    default:
                    {
                        xdrParamsName = "args";
                        outputFile.Write($"            var args = new {paramClassName}();\n");
                        foreach (ParsedDeclaration parameter in proc.Parameters)
                        {
                            outputFile.Write($"            args.{parameter.Identifier} = {parameter.Identifier};\n");
                        }

                        break;
                    }
                }

                outputFile.Write($"            var result = new {resultClassName}();\n");

                // Now emit the real ONC/RPC call using the (optionally wrapped) parameter and (optionally wrapped)
                // result
                outputFile.Write(
                    $"            Call({ConstantsClassname}.{proc.ProcedureId}, {ConstantsClassname}.{versionInfo.VersionId}, {xdrParamsName}, result);\n");

                // In case of a wrapped result we need to return the value of the wrapper, otherwise we can return the
                // result itself (which then is not a base data type). As a special case, we can not return void
                // values...anyone for a language design with first class void objects?!
                if (IsBaseType(proc.ResultType))
                {
                    // Data type of result is a C# base data type, so we need to unwrap the XDR-able result -- if it's
                    // not a void, which we do not need to return at all
                    if (!IsVoid(proc.ResultType))
                    {
                        outputFile.Write("            return result.Value;\n");
                    }
                }
                else
                {
                    // Data type of result is a complex type (class), so we do not unwrap it but can return it
                    // immediately
                    outputFile.Write("            return result;\n");
                }

                // Close the stub method (just as a hint, as it is getting rather difficult to see what code is produced
                // at this stage...)
                outputFile.Write("        }\n");
            }
        }

        private static void DumpClientArgumentStruct(ParsedProcedureInfo proc, string paramClassName)
        {
            outputFile.Write("\n");
            outputFile.Write("        private class " + paramClassName + " : IXdrWritable\n");
            outputFile.Write("        {\n");
            foreach (ParsedDeclaration paramInfo in proc.Parameters)
            {
                outputFile.Write($"            public {CheckForSpecials(paramInfo.DataType)} {paramInfo.Identifier};\n");
            }

            if (proc.Parameters.Count > 0)
            {
                outputFile.Write("\n");
            }

            outputFile.Write("            public void WriteTo(IXdrWriter writer)\n");
            outputFile.Write("            {\n");

            // Emit serialization code for all parameters. Note that not we do not need to deal with all kinds
            // of parameters here, as things like "int<5>" are invalid, a typedef declaration is then necessary
            foreach (ParsedDeclaration paramInfo in proc.Parameters)
            {
                outputFile.Write("        ");
                outputFile.Write(CodingMethod(paramInfo, true));
            }

            outputFile.Write("            }\n");
            outputFile.Write("        }\n");
        }

        private static void DumpClientResultStruct(ParsedProcedureInfo proc, string resultClassName)
        {
            outputFile.Write("\n");
            outputFile.Write("        private class " + resultClassName + " : IXdrReadable\n");
            outputFile.Write("        {\n");
            if (!IsVoid(proc.ResultType))
            {
                outputFile.Write($"            public {CheckForSpecials(proc.ResultType)} Value;\n");
                outputFile.Write("\n");
            }

            outputFile.Write("            public void ReadFrom(IXdrReader reader)\n");
            outputFile.Write("            {\n");
            if (!IsVoid(proc.ResultType))
            {
                outputFile.Write("        ");
                outputFile.Write(CodingMethod(new ParsedDeclaration("Value", proc.ResultType), false));
            }

            outputFile.Write("            }\n");
            outputFile.Write("        }\n");
        }

        private static void DumpClient(ParsedProgramInfo programInfo)
        {
            // When several versions of a program are defined, we search for the latest and greatest one. This highest
            // version number ist then used to create the necessary RpcClient for communication when the
            // client proxy stub is constructed
            ParsedVersionInfo version = programInfo.Versions[0];
            int versionNumber = int.Parse(version.VersionNumber);
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                int anotherVersion = int.Parse(versionInfo.VersionNumber);
                if (anotherVersion > versionNumber)
                {
                    versionNumber = anotherVersion;
                    version = versionInfo;
                }
            }

            // Create new source code file containing a C# class representing the XDR struct. In case we have several
            // programs defines, build the source code file name from the program's name (this case is identified by a
            // null clientClass name)
            string clientClass = BaseClassname + "Client";

            outputFile.Write("\n");

            outputFile.Write($"    internal class {clientClass} : ClientStub\n");
            outputFile.Write("    {\n");
            outputFile.Write($"        public {clientClass}(Protocol protocol, IPAddress ipAddress, int port = 0, ILogger logger = null) :\n");
            outputFile.Write(
                $"            base(protocol, ipAddress, port, {ConstantsClassname}.{programInfo.ProgramId}, {ConstantsClassname}.{version.VersionId}, logger)\n");
            outputFile.Write("        {\n");
            outputFile.Write("        }\n");

            // Generate method stubs... This is getting hairy in case someone uses basic data types as parameters or the
            // procedure's result. In these cases we need to encapsulate these basic data types in XDR-able data types
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                DumpClientStubMethods(versionInfo);
            }

            outputFile.Write("    }\n");
        }

        private static void DumpServerArgumentStruct(ParsedProcedureInfo proc)
        {
            outputFile.Write("\n");
            outputFile.Write($"        private class Arguments_{proc.ProcedureNumber} : IXdrReadable\n");
            outputFile.Write("        {\n");
            foreach (ParsedDeclaration parameter in proc.Parameters)
            {
                outputFile.Write($"            public {CheckForSpecials(parameter.DataType)} {parameter.Identifier};\n");
            }

            if (proc.Parameters.Count > 0)
            {
                outputFile.Write("\n");
            }

            outputFile.Write("            public void ReadFrom(IXdrReader reader)\n");
            outputFile.Write("            {\n");

            // Emit serialization code for all parameters. Note that not we do not need to deal with all kinds
            // of parameters here, as things like "int<5>" are invalid, a typedef declaration is then necessary
            foreach (ParsedDeclaration parameter in proc.Parameters)
            {
                outputFile.Write("        " + CodingMethod(parameter, false));
            }

            outputFile.Write("            }\n");
            outputFile.Write("        }\n");
        }

        private static void DumpServerResultStruct(ParsedProcedureInfo proc)
        {
            outputFile.Write("\n");
            outputFile.Write($"        private class Result_{proc.ProcedureNumber} : IXdrWritable\n");
            outputFile.Write("        {\n");
            if (!IsVoid(proc.ResultType))
            {
                outputFile.Write($"            public {CheckForSpecials(proc.ResultType)} Value;\n");
                outputFile.Write("\n");
            }

            outputFile.Write("            public void WriteTo(IXdrWriter writer)\n");
            outputFile.Write("            {\n");
            if (!IsVoid(proc.ResultType))
            {
                outputFile.Write("        ");
                outputFile.Write(CodingMethod(new ParsedDeclaration("Value", proc.ResultType), true));
            }

            outputFile.Write("            }\n");
            outputFile.Write("        }\n");
        }

        private static void DumpServerStubMethodCall(ParsedProcedureInfo proc)
        {
            // Check for special return types, like enumerations, which we map to their corresponding C# base data type
            string resultType = CheckForSpecials(proc.ResultType);

            // If the remote procedure does not have any parameters, then parameters will be null. Otherwise it contains
            // a vector with information about the individual parameters, which we use in order to generate the
            // parameter list. Note that all parameters are named at this point (they will either have a user supplied
            // name, or an automatically generated one)
            ParameterKind paramsKind;
            int parametersCount = proc.Parameters.Count;

            // Now find out what kind of parameter(s) we have. In case the remote procedure only expects a single
            // parameter, check whether it is a base type. In this case we later need to wrap the single parameter.
            // If the remote procedure expects more than a single parameter, then we always need a XDR wrapper
            if (parametersCount > 1)
            {
                paramsKind = ParameterKind.More;
            }
            else if (parametersCount == 0)
            {
                paramsKind = ParameterKind.Void;
            }
            else
            {
                // parametersCount must be equal to one, otherwise proc.parameters must have been null
                string firstParamType = proc.Parameters[0].DataType;
                paramsKind = XdrBaseType(CheckForSpecials(firstParamType)) == null ? ParameterKind.Single : ParameterKind.SingleBaseType;
            }

            // Do generate code for unwrapping here, if necessary
            string @params;
            switch (paramsKind)
            {
                case ParameterKind.Single:
                {
                    // Only a single parameter, which is in addition immediately ready for serialization
                    ParsedDeclaration paramInfo = proc.Parameters[0];
                    outputFile.Write($"                        var args = new {paramInfo.DataType}();\n");
                    outputFile.Write("                        call.RetrieveCall(args);\n");
                    @params = "call.RemoteIpEndPoint, args";
                    break;
                }

                default:
                {
                    // We only need to refer to the struct here, we don't declare it as that isn't valid C# syntax
                    outputFile.Write($"                        var args = new Arguments_{proc.ProcedureNumber}();\n");
                    outputFile.Write("                        call.RetrieveCall(args);\n");
                    var paramsBuff = new StringBuilder();
                    paramsBuff.Append("call.RemoteIpEndPoint");

                    foreach (ParsedDeclaration parameter in proc.Parameters)
                    {
                        paramsBuff.Append(", args.");
                        paramsBuff.Append(parameter.Identifier);
                    }

                    @params = paramsBuff.ToString();
                    break;
                }
            }

            // Check the return data type of the result to be of one of the base data types, like int, boolean, etc. In
            // this case we have to unwrap the result from one of the special XDR wrapper classes and return the base
            // data type instead
            if (IsVoid(resultType))
            {
                // It's a remote procedure, so it does return simply nothing. We use the singleton Void to return a
                // "nothing"
                outputFile.Write($"                        {proc.ProcedureId}({@params});\n");
                outputFile.Write($"                        call.Reply(new Result_{proc.ProcedureNumber}());\n");
            }
            else if (IsBaseType(resultType))
            {
                // The return type is some C# base data type, so we need to wrap the return value before we can
                // serialize it
                outputFile.Write($"                        var result = new Result_{proc.ProcedureNumber}();\n");
                outputFile.Write($"                        result.Value = {proc.ProcedureId}({@params});\n");
                outputFile.Write("                        call.Reply(result);\n");
            }
            else
            {
                // The return type is a complex type which supports IXdrAble
                outputFile.Write($"                        var result = {proc.ProcedureId}({@params});\n");
                outputFile.Write("                        call.Reply(result);\n");
            }
        }

        private static void DumpServerStubMethods(ParsedVersionInfo versionInfo)
        {
            foreach (ParsedProcedureInfo procedure in versionInfo.Procedures)
            {
                string resultType = CheckForSpecials(procedure.ResultType);
                outputFile.Write($"        public abstract {resultType} {procedure.ProcedureId}(IPEndPoint remoteIpEndPoint");
                foreach (ParsedDeclaration parameter in procedure.Parameters)
                {
                    outputFile.Write(", ");
                    outputFile.Write(CheckForSpecials(parameter.DataType));
                    outputFile.Write(" ");
                    outputFile.Write(parameter.Identifier);
                }

                outputFile.Write(");\n");
            }
        }

        private static void DumpServer(ParsedProgramInfo programInfo)
        {
            string serverClass = BaseClassname + "ServerStub";

            string versions = string.Join(", ", programInfo.Versions.Select(version => ConstantsClassname + "." + version.VersionId));

            outputFile.Write("\n");
            outputFile.Write($"    internal abstract class {serverClass} : ServerStub\n");
            outputFile.Write("    {\n");
            outputFile.Write($"        public {serverClass}(Protocols protocols, IPAddress ipAddress, int port = 0, ILogger logger = null) :\n");
            outputFile.Write($"            base(protocols, ipAddress, port, {ConstantsClassname}.{programInfo.ProgramId}, new[] {{ {versions} }}, logger)\n");
            outputFile.Write("        {\n");
            outputFile.Write("        }\n");

            // First we need to create all the structs so that they are outside member function scope for C#.
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                foreach (ParsedProcedureInfo procedure in versionInfo.Procedures)
                {
                    if ((procedure.Parameters.Count == 0) ||
                        (procedure.Parameters.Count > 1) ||
                        IsBaseType(procedure.Parameters[0].DataType) ||
                        IsEnum(procedure.Parameters[0].DataType))
                    {
                        DumpServerArgumentStruct(procedure);
                    }

                    if (IsBaseType(procedure.ResultType) || IsEnum(procedure.ResultType))
                    {
                        DumpServerResultStruct(procedure);
                    }
                }
            }

            // Now generate dispatcher code using the previously generated structs where applicable
            outputFile.Write("\n");
            outputFile.Write("        protected override void DispatchReceivedCall(ReceivedCall call)\n");
            outputFile.Write("        {\n");
            bool first = true;
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                if (first)
                {
                    first = false;
                    outputFile.Write($"            if (call.Version == {ConstantsClassname}.{versionInfo.VersionId})\n");
                    outputFile.Write("            {\n");
                }
                else
                {
                    outputFile.Write("            }\n");
                    outputFile.Write($"            else if (call.Version == {ConstantsClassname}.{versionInfo.VersionId})\n");
                    outputFile.Write("            {\n");
                }

                outputFile.Write("                switch (call.Procedure)\n");
                outputFile.Write("                {\n");
                foreach (ParsedProcedureInfo procInfo in versionInfo.Procedures)
                {
                    // Emit case arms for every procedure defined. We have to take care that the procedure number might
                    // be a constant coming from an enumeration: in this case we need also to dump the enclosure
                    outputFile.Write($"                    case {ConstantsClassname}.{procInfo.ProcedureId}:\n");
                    outputFile.Write("                    {\n");
                    DumpServerStubMethodCall(procInfo);
                    outputFile.Write("                        break;\n");
                    outputFile.Write("                    }\n");
                }

                outputFile.Write("                    default:\n");
                outputFile.Write("                        call.ProcedureUnavailable();\n");
                outputFile.Write("                        break;\n");
                outputFile.Write("                }\n");
            }

            outputFile.Write("            }\n");
            outputFile.Write("            else\n");
            outputFile.Write("            {\n");
            outputFile.Write("                call.ProgramMismatch();\n");
            outputFile.Write("            }\n");
            outputFile.Write("        }\n");
            outputFile.Write("\n");

            // Generate the abstract stub methods for all specified remote procedures.
            foreach (ParsedVersionInfo versionInfo in programInfo.Versions)
            {
                DumpServerStubMethods(versionInfo);
            }

            outputFile.Write("    }\n");
        }

        private static void DumpFiles()
        {
            DumpConstants();
            DumpClasses();
            foreach (ParsedProgramInfo programInfo in programInfos)
            {
                DumpClient(programInfo);
                DumpServer(programInfo);
            }
        }

        private static void Main(string[] args)
        {
            // First parse the command line (options)...
            int argc = args.Length;
            int argIdx = 0;
            for (; argIdx < argc; ++argIdx)
            {
                // Check to see whether this is an option...
                string arg = args[argIdx].ToLower();
                if ((arg.Length > 0) && (arg[0] != '-'))
                {
                    break;
                }

                switch (arg)
                {
                    case "-o":
                        // -o <output file>
                        if (++argIdx >= argc)
                        {
                            Console.WriteLine("RpcNetGen: missing output file");
                            Environment.Exit(1);
                        }

                        outputFilePath = Path.GetFullPath(args[argIdx]);
                        break;
                    case "-n":
                        // -n <namespace>
                        if (++argIdx >= argc)
                        {
                            Console.WriteLine("RpcNetGen: missing namespace");
                            Environment.Exit(1);
                        }

                        @namespace = args[argIdx];
                        break;
                    case "-version":
                        Console.WriteLine("RpcNetGen version \"" + Version + "\"");
                        Environment.Exit(1);
                        break;
                    case "-help":
                    case "-?":
                        PrintHelp();
                        Environment.Exit(1);
                        break;
                    default:
                        // It's an unknown option!
                        Console.WriteLine("Unrecognized option: " + arg);
                        Environment.Exit(1);
                        break;
                }
            }

            // Otherwise we regard the current command line argument to be the name of the x-file to compile. Check,
            // that there is exactly one x-file specified
            if ((argIdx >= argc) || (argIdx < (argc - 1)))
            {
                PrintHelp();
                Environment.Exit(1);
            }

            inputFilePath = Path.GetFullPath(args[argIdx]);
            BaseClassname = Path.GetFileNameWithoutExtension(inputFilePath);
            ConstantsClassname = BaseClassname + "Constants";
            if (string.IsNullOrWhiteSpace(outputFilePath))
            {
                string directoryName = Path.GetDirectoryName(inputFilePath);
                outputFilePath = Path.Combine(directoryName, BaseClassname + ".cs");
            }

            // Try to parse the file and generate the different class source code files...
            try
            {
                DoParse();
            }
            catch (Exception t)
            {
                Console.WriteLine(t);
                Environment.Exit(1);
            }
        }

        private static void DoParse()
        {
            StreamReader @in;
            try
            {
                @in = new StreamReader(inputFilePath);
            }
            catch (FileNotFoundException)
            {
                throw new FileNotFoundException($"RpcNetGen: can not open source x-file \"{Path.GetFullPath(inputFilePath)}\"");
            }

            var scanner = new Scanner(@in);
            var parser = new Parser(scanner);
            GlobalIdentifiers["TRUE"] = new ParsedConst("TRUE", "true");
            GlobalIdentifiers["FALSE"] = new ParsedConst("FALSE", "false");
            try
            {
                parser.parse();
                CreateSourceFile();
                DumpFiles();
                CloseSourceFile();
            }
            catch (ParserException pe)
            {
                throw new Exception("RpcNetGen: compilation aborted (" + pe.Message + ")");
            }
        }

        private static bool IsEnum(string identifier) => GlobalIdentifiers.TryGetValue(identifier, out ParsedElementBase element) && element is ParsedEnum;

        private enum ParameterKind
        {
            Void,
            Single,
            SingleBaseType,
            More
        }

        private class WriteReadOptions
        {
            public WriteReadOptions(string writeFunction, string readFunction, string writeAppendix, string readAppendix, bool isEnum)
            {
                this.WriteFunction = writeFunction;
                this.ReadFunction = readFunction;
                this.WriteAppendix = writeAppendix ?? string.Empty;
                this.ReadAppendix = readAppendix ?? string.Empty;
                this.IsEnum = isEnum;
            }

            public string WriteFunction { get; }
            public string ReadFunction { get; }
            public string WriteAppendix { get; }
            public string ReadAppendix { get; }
            public bool IsEnum { get; }
        }
    }
}
